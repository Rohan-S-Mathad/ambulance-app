"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeFiles = void 0;
const serverless_api_1 = require("@twilio-labs/serverless-api");
const chalk_1 = __importDefault(require("chalk"));
const dotenv_1 = __importDefault(require("dotenv"));
const got_1 = __importDefault(require("got"));
const listr2_1 = require("listr2");
const path_1 = __importDefault(require("path"));
const pkg_install_1 = require("pkg-install");
const semver_1 = __importDefault(require("semver"));
const fs_1 = require("../utils/fs");
const logger_1 = require("../utils/logger");
async function writeEnvFile(contentUrl, targetDir, functionName) {
    const envFilePath = path_1.default.join(targetDir, '.env');
    const envFileExists = await (0, fs_1.fileExists)(envFilePath, true);
    if (!envFileExists) {
        await (0, fs_1.downloadFile)(contentUrl, envFilePath);
        return { newEnvironmentVariableKeys: [] };
    }
    const currentContent = await (0, fs_1.readFile)(envFilePath, 'utf8');
    const currentFlags = dotenv_1.default.parse(currentContent);
    const newContent = (await (0, got_1.default)(contentUrl)).body;
    const newFlags = dotenv_1.default.parse(newContent);
    const functionKeys = Object.keys(newFlags);
    const existingKeys = functionKeys.filter((key) => currentFlags.hasOwnProperty(key));
    const updatedContent = newContent
        .split('\n')
        .map((line) => {
        const name = line.substr(0, line.indexOf('='));
        if (existingKeys.includes(name)) {
            return '# ' + line;
        }
        return line;
    })
        .join('\n');
    const separatorContent = `

# Variables for function "${functionName}"
# ---
`;
    const contentToWrite = currentContent + separatorContent + updatedContent;
    await (0, fs_1.writeFile)(envFilePath, contentToWrite, 'utf8');
    return { newEnvironmentVariableKeys: functionKeys };
}
async function installDependencies(contentUrl, targetDir) {
    const pkgContent = await (0, got_1.default)(contentUrl, { responseType: 'json' });
    const dependencies = {};
    const exactDependencies = {};
    const pkgContentBody = pkgContent.body;
    Object.entries(pkgContentBody.dependencies || []).forEach(([name, version]) => {
        if (Boolean(semver_1.default.parse(version))) {
            exactDependencies[name] = version;
        }
        else {
            dependencies[name] = version;
        }
    });
    if (exactDependencies && Object.keys(exactDependencies).length > 0) {
        await (0, pkg_install_1.install)(exactDependencies, {
            cwd: targetDir,
            exact: true,
        });
    }
    if (dependencies && Object.keys(dependencies).length > 0) {
        return (0, pkg_install_1.install)(dependencies, {
            cwd: targetDir,
        });
    }
}
function hasFilesOfType(files, type) {
    for (let file of files) {
        if (file.type === type) {
            return true;
        }
    }
    return false;
}
async function writeFiles(files, targetDir, namespace, templateName) {
    const functionsDir = serverless_api_1.fsHelpers.getFirstMatchingDirectory(targetDir, [
        'functions',
        'src',
    ]);
    const assetsDir = serverless_api_1.fsHelpers.getFirstMatchingDirectory(targetDir, [
        'assets',
        'static',
    ]);
    const functionsTargetDir = path_1.default.join(functionsDir, namespace);
    const assetsTargetDir = path_1.default.join(assetsDir, namespace);
    const readmesTargetDir = path_1.default.join(targetDir, 'readmes', namespace);
    if (functionsTargetDir !== functionsDir) {
        if (hasFilesOfType(files, 'functions')) {
            await (0, fs_1.mkdir)(functionsTargetDir, { recursive: true });
        }
        if (hasFilesOfType(files, 'assets')) {
            await (0, fs_1.mkdir)(assetsTargetDir, { recursive: true });
        }
    }
    if (hasFilesOfType(files, 'README.md')) {
        await (0, fs_1.mkdir)(readmesTargetDir, { recursive: true });
    }
    for (let file of files) {
        if (file.type === 'functions') {
            let filepath = path_1.default.join(functionsTargetDir, file.directory, file.name);
            if (await (0, fs_1.fileExists)(filepath)) {
                throw new Error(`Template with name "${namespace}" has duplicate file "${file.name}" in "${functionsDir}"`);
            }
        }
        else if (file.type === 'assets') {
            let filepath = path_1.default.join(assetsTargetDir, file.directory, file.name);
            if (await (0, fs_1.fileExists)(filepath)) {
                throw new Error(`Template with name "${namespace}" has duplicate file "${file.name}" in "${assetsDir}"`);
            }
        }
    }
    const tasks = files
        .map((file) => {
        if (file.type === 'functions') {
            return {
                title: `Creating function: ${path_1.default.join(file.directory, file.name)}`,
                task: () => (0, fs_1.downloadFile)(file.content, path_1.default.join(functionsTargetDir, file.directory, file.name)),
            };
        }
        else if (file.type === 'assets') {
            return {
                title: `Creating asset: ${file.name}`,
                task: () => (0, fs_1.downloadFile)(file.content, path_1.default.join(assetsTargetDir, file.directory, file.name)),
            };
        }
        else if (file.type === '.env' || file.type === '.env.example') {
            return {
                title: 'Configuring Environment Variables in .env',
                task: async (ctx) => {
                    const output = await writeEnvFile(file.content, targetDir, namespace);
                    ctx.env = output;
                },
            };
        }
        else if (file.type === 'package.json') {
            return {
                title: 'Installing Dependencies',
                task: () => installDependencies(file.content, targetDir),
            };
        }
        else if (file.type === 'README.md') {
            const readmePath = path_1.default.join(readmesTargetDir, templateName + '.md');
            return {
                title: `Saving README to ${readmePath}`,
                task: async () => {
                    if (await (0, fs_1.fileExists)(readmePath)) {
                        return;
                    }
                    return (0, fs_1.downloadFile)(file.content, readmePath);
                },
            };
        }
    })
        .filter(Boolean);
    const context = await new listr2_1.Listr(tasks, { concurrent: true }).run();
    const newKeys = context.env.newEnvironmentVariableKeys;
    if (newKeys.length > 0) {
        logger_1.logger.info((0, chalk_1.default) `{cyan INFO} Make sure to configure ${newKeys.join(',')} in the .env file`);
    }
}
exports.writeFiles = writeFiles;
