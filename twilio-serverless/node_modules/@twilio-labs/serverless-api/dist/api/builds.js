"use strict";
/** @module @twilio-labs/serverless-api/dist/api */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.activateBuild = exports.waitForSuccessfulBuild = exports.triggerBuild = exports.listBuilds = exports.getBuildStatus = exports.getBuild = void 0;
const debug_1 = __importDefault(require("debug"));
const querystring_1 = __importDefault(require("querystring"));
const consts_1 = require("../types/consts");
const error_1 = require("../utils/error");
const sleep_1 = require("../utils/sleep");
const pagination_1 = require("./utils/pagination");
const log = (0, debug_1.default)('twilio-serverless-api:builds');
/**
 * Retrieves a specific build by its SID
 *
 * @export
 * @param {string} buildSid SID of build to retrieve
 * @param {string} serviceSid service to retrieve build from
 * @param {TwilioServerlessApiClient} client API client
 * @returns {Promise<BuildResource>}
 */
async function getBuild(buildSid, serviceSid, client) {
    const resp = await client.request('get', `Services/${serviceSid}/Builds/${buildSid}`);
    return resp.body;
}
exports.getBuild = getBuild;
/**
 * Returns the current status of a build given its SID
 *
 * @param {string} buildSid the SID of the build
 * @param {string} serviceSid the SID of the service the build belongs to
 * @param {TwilioServerlessApiClient} client API client
 * @returns {Promise<BuildStatus>}
 */
async function getBuildStatus(buildSid, serviceSid, client) {
    try {
        const resp = await client.request('get', `Services/${serviceSid}/Builds/${buildSid}/Status`);
        return resp.body.status;
    }
    catch (err) {
        log('%O', new error_1.ClientApiError(err));
        throw err;
    }
}
exports.getBuildStatus = getBuildStatus;
/**
 * Returns a list of all builds related to service
 *
 * @export
 * @param {string} serviceSid the SID of the service
 * @param {TwilioServerlessApiClient} client API client
 * @returns {Promise<BuildResource[]>}
 */
async function listBuilds(serviceSid, client) {
    return (0, pagination_1.getPaginatedResource)(client, `Services/${serviceSid}/Builds`);
}
exports.listBuilds = listBuilds;
/**
 * Triggers a new build by creating it
 *
 * @export
 * @param {BuildConfig} config build-related information (functions, assets, dependencies)
 * @param {string} serviceSid the service to create the build for
 * @param {TwilioServerlessApiClient} client API client
 * @returns {Promise<BuildResource>}
 */
async function triggerBuild(config, serviceSid, client) {
    const { functionVersions, dependencies, assetVersions, runtime } = config;
    try {
        const body = {};
        if (Array.isArray(dependencies) && dependencies.length > 0) {
            const dependencyString = `"${JSON.stringify(dependencies)}"`;
            body.Dependencies = dependencyString;
        }
        if (Array.isArray(functionVersions) && functionVersions.length > 0) {
            body.FunctionVersions = functionVersions;
        }
        if (Array.isArray(assetVersions) && assetVersions.length > 0) {
            body.AssetVersions = assetVersions;
        }
        if (runtime) {
            body.Runtime = runtime;
        }
        const resp = await client.request('post', `Services/${serviceSid}/Builds`, {
            responseType: 'json',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: querystring_1.default.stringify(body),
        });
        return resp.body;
    }
    catch (err) {
        log('%O', new error_1.ClientApiError(err));
        throw err;
    }
}
exports.triggerBuild = triggerBuild;
/**
 * Resolves only when build has been completed. Will timeout after specified time.
 *
 * @export
 * @param {string} buildSid the build to wait for
 * @param {string} serviceSid the service of the build
 * @param {TwilioServerlessApiClient} client API client
 * @param {events.EventEmitter} eventEmitter optional event emitter to communicate current build status
 * @param {number} timeout optional timeout. default: 5 minutes
 * @returns {Promise<void>}
 */
function waitForSuccessfulBuild(buildSid, serviceSid, client, eventEmitter, timeout = 5 * 60 * 1000) {
    return new Promise(async (resolve, reject) => {
        const startTime = Date.now();
        let isBuilt = false;
        while (!isBuilt) {
            if (Date.now() - startTime > timeout) {
                eventEmitter.emit('status-update', {
                    status: consts_1.DeployStatus.TIMED_OUT,
                    message: 'Deployment took too long',
                });
                reject(new Error('Timeout'));
            }
            const status = await getBuildStatus(buildSid, serviceSid, client);
            isBuilt = status === 'completed';
            if (isBuilt) {
                break;
            }
            const hasFailed = status === 'failed';
            if (hasFailed) {
                reject(status);
                return;
            }
            eventEmitter.emit('status-update', {
                status: consts_1.DeployStatus.BUILDING,
                message: `Waiting for deployment. Current status: ${status}`,
            });
            await (0, sleep_1.sleep)(1000);
        }
        resolve();
    });
}
exports.waitForSuccessfulBuild = waitForSuccessfulBuild;
/**
 * Activates a specific build for a given environment by creating a new deployment
 *
 * @export
 * @param {string} buildSid the build to be activated
 * @param {string} environmentSid the target environment for the build to be deployed to
 * @param {string} serviceSid the service of the project
 * @param {TwilioServerlessApiClient} client API client
 * @returns {Promise<any>}
 */
async function activateBuild(buildSid, environmentSid, serviceSid, client) {
    try {
        const resp = await client.request('post', `Services/${serviceSid}/Environments/${environmentSid}/Deployments`, {
            form: {
                BuildSid: buildSid,
            },
        });
        return resp.body;
    }
    catch (err) {
        log('%O', new error_1.ClientApiError(err));
        throw err;
    }
}
exports.activateBuild = activateBuild;
